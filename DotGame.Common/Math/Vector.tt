<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ include file="Manager.ttinclude"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

<#
var manager = Manager.Create(this.Host, this.GenerationEnvironment);
for (int i=2; i<=4; i++)
{
	manager.StartNewFile(string.Format("Vector{0}.cs", i));
#>using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace DotGame
{
    /// <summary>
    /// Ein Vektor mit <#=i#> Komponenten.
    /// </summary>
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public struct Vector<#=i#> : IEquatable<Vector<#=i#>>
    {
        /// <summary>
        /// Die X-Komponente des Vektors.
        /// </summary>
        public float X;

        /// <summary>
        /// Die Y-Komponente des Vektors.
        /// </summary>
        public float Y;
		<# if (i > 2) { #>

        /// <summary>
        /// Die Z-Komponente des Vektors.
        /// </summary>
        public float Z;
		<# if (i > 3) { #>

        /// <summary>
        /// Die W-Komponente des Vektors.
        /// </summary>
        public float W;
		<# }} #>

        #region Konstanten
        /// <summary>
        /// Die Größte des Vector<#=i#>-Structs in Bytes.
        /// </summary>
        public static int SizeInBytes { get { return sizeInBytes; } }

        /// <summary>
        /// <#= Ctor(i, 0, 0, 0, 0) #>.
        /// </summary>
        public static Vector<#=i#> Zero { get { return zero; } }

        /// <summary>
        /// <#= Ctor(i, 1, 0, 0, 0) #>.
        /// </summary>
        public static Vector<#=i#> UnitX { get { return unitX; } }

        /// <summary>
        /// <#= Ctor(i, 0, 1, 0, 0) #>.
        /// </summary>
        public static Vector<#=i#> UnitY { get { return unitY; } }
		<# if (i > 2) { #>

        /// <summary>
        /// <#= Ctor(i, 0, 0, 1, 0) #>.
        /// </summary>
        public static Vector<#=i#> UnitZ { get { return unitZ; } }
		<# if (i > 3) { #>

        /// <summary>
        /// <#= Ctor(i, 0, 0, 0, 1) #>.
        /// </summary>
        public static Vector<#=i#> UnitW { get { return unitW; } }
		<# } } #>

        /// <summary>
        /// <#= Ctor(i, 1, 1, 1, 1) #>.
        /// </summary>
        public static Vector<#=i#> One { get { return one; } }

        private static readonly int sizeInBytes = Marshal.SizeOf(typeof(Vector<#=i#>));
        private static readonly Vector<#=i#> zero = new Vector<#=i#>(0);
        private static readonly Vector<#=i#> unitX = new <#= Ctor(i, 1, 0, 0, 0) #>;
        private static readonly Vector<#=i#> unitY = new <#= Ctor(i, 0, 1, 0, 0) #>;
<# if (i > 2) { #>
        private static readonly Vector<#=i#> unitZ = new <#= Ctor(i, 0, 0, 1, 0) #>;
<# if (i > 3) { #>
        private static readonly Vector<#=i#> unitW = new <#= Ctor(i, 0, 0, 0, 1) #>;
<# } } #>
        private static readonly Vector<#=i#> one = new Vector<#=i#>(1);
        #endregion

        /// <summary>
        /// Erstellt einen Vektor und setzt alle Komponenten auf value.
        /// </summary>
        /// <param name="value">Der Wert für alle Komponenten.</param>
        public Vector<#=i#>(float value)
        {
            this.X = value;
            this.Y = value;
<# if (i > 2) #>
            this.Z = value;
<# if (i > 3) #>
            this.W = value;
<##>
        }

        /// <summary>
        /// Erstellt einen Vektor mit den angegebenen Werten.
        /// </summary>
        /// <param name="x">Die X Komponente.</param>
        /// <param name="y">Die Y Komponente.</param>
<# if (i > 2) #>
        /// <param name="z">Die Z Komponente.</param>
<# if (i > 3) #>
        /// <param name="w">Die W Komponente.</param>
<##>
        public Vector<#=i#>(float x, float y<# if (i > 2) #>, float z<# if (i > 3) #>, float w<##>)
        {
            this.X = x;
            this.Y = y;
<# if (i > 2) #>
            this.Z = z;
<# if (i > 3) #>
            this.W = w;
<##>
        }

        /// <summary>
        /// Gibt die Länge des Vektors zurück.
        /// </summary>
        /// <returns>Die Länge.</returns>
        public float Length()
        {
            return (float)Math.Sqrt(LengthSquared());
        }

        /// <summary>
        /// Gibt die quadrierte Länge zurück.
        /// </summary>
        /// <returns>Die quadrierte Länge.</returns>
        public float LengthSquared()
        {
            return X * X + Y * Y<# if (i > 2) #> + Z * Z<# if (i > 3) #> + W * W<##>;
        }

        /// <summary>
        /// Normalisiert den Vektor. Seine Länge beträgt danach 1.
        /// </summary>
        public void Normalize()
        {
            float length = Length();
            X /= length;
            Y /= length;
<# if (i > 2) #>
            Z /= length;
<# if (i > 3) #>
            W /= length;
<##>
        }

        #region Operatoren
        public static bool operator ==(Vector<#=i#> value1, Vector<#=i#> value2)
        {
            return value1.X == value2.X
                && value1.Y == value2.Y
<# if (i > 2) #>
                && value1.Z == value2.Z
<# if (i > 3) #>
                && value1.W == value2.W
<##>;
        }
        public static bool operator !=(Vector<#=i#> value1, Vector<#=i#> value2)
        {
            return !(value1 == value2);
        }
        public static Vector<#=i#> operator +(Vector<#=i#> a)
        {
            return a;
        }
        public static Vector<#=i#> operator +(Vector<#=i#> a, Vector<#=i#> b)
        {
			return new <#= Op(i, "+", "a.X {0} b.X", "a.Y {0} b.Y", "a.Z {0} b.Z", "a.W {0} b.W") #>;
        }
        public static Vector<#=i#> operator -(Vector<#=i#> a)
        {
            return new <#= Ctor(i, "-a.X", "-a.Y", "-a.Z", "-a.W") #>;
        }
        public static Vector<#=i#> operator -(Vector<#=i#> a, Vector<#=i#> b)
        {
			return new <#= Op(i, "-", "a.X {0} b.X", "a.Y {0} b.Y", "a.Z {0} b.Z", "a.W {0} b.W") #>;
        }
        public static Vector<#=i#> operator *(Vector<#=i#> a, Vector<#=i#> b)
        {
			return new <#= Op(i, "*", "a.X {0} b.X", "a.Y {0} b.Y", "a.Z {0} b.Z", "a.W {0} b.W") #>;
        }
        public static Vector<#=i#> operator *(Vector<#=i#> a, float scalar)
        {
			return new <#= Op(i, "*", "a.X {0} scalar", "a.Y {0} scalar", "a.Z {0} scalar", "a.W {0} scalar") #>;
        }
        public static Vector<#=i#> operator /(Vector<#=i#> a, Vector<#=i#> b)
        {
			return new <#= Op(i, "/", "a.X {0} b.X", "a.Y {0} b.Y", "a.Z {0} b.Z", "a.W {0} b.W") #>;
        }
        public static Vector<#=i#> operator /(Vector<#=i#> a, float scalar)
        {
			return new <#= Op(i, "/", "a.X {0} scalar", "a.Y {0} scalar", "a.Z {0} scalar", "a.W {0} scalar") #>;
        }
        public static Vector<#=i#> operator %(Vector<#=i#> a, Vector<#=i#> b)
        {
			return new <#= Op(i, "%", "a.X {0} b.X", "a.Y {0} b.Y", "a.Z {0} b.Z", "a.W {0} b.W") #>;
        }
        public static Vector<#=i#> operator %(Vector<#=i#> a, float scalar)
        {
			return new <#= Op(i, "%", "a.X {0} scalar", "a.Y {0} scalar", "a.Z {0} scalar", "a.W {0} scalar") #>;
        }
        #endregion

        #region Statische Methoden
        /// <summary>
        /// Gibt das Minimum zweier Vektoren zurück.
        /// </summary>
        /// <param name="value1">Der erste Vektor.</param>
        /// <param name="value2">Der zweite Vektor.</param>
        /// <returns>Das Minimum der Komponenten als Vector<#=i#>.</returns>
        public static Vector<#=i#> Min(Vector<#=i#> value1, Vector<#=i#> value2)
        {
            Vector<#=i#> result;
            Min(ref value1, ref value2, out result);
            return result;
        }

        /// <summary>
        /// Gibt das Minimum zweiter Vektoren zurück.
        /// </summary>
        /// <param name="value1">Der erste Vektor.</param>
        /// <param name="value2">Der zweite Vektor.</param>
        /// <param name="result">Das Minimum der Komponenten als Vector<#=i#>.</param>
        public static void Min(ref Vector<#=i#> value1, ref Vector<#=i#> value2, out Vector<#=i#> result)
        {
            result.X = value1.X < value2.X ? value1.X : value2.X;
            result.Y = value1.Y < value2.Y ? value1.Y : value2.Y;
<# if (i > 2) #>
            result.Z = value1.Z < value2.Z ? value1.Z : value2.Z;
<# if (i > 3) #>
            result.W = value1.W < value2.W ? value1.W : value2.W;
<##>
        }

        /// <summary>
        /// Gibt das Maximum zweiter Vektoren zurück.
        /// </summary>
        /// <param name="value1">Der erste Vektor.</param>
        /// <param name="value2">Der zweite Vektor.</param>
        /// <returns>Das Maximum der Komponenten als Vector<#=i#>.</returns>
        public static Vector<#=i#> Max(Vector<#=i#> value1, Vector<#=i#> value2)
        {
            Vector<#=i#> result;
            Max(ref value1, ref value2, out result);
            return result;
        }

        /// <summary>
        /// Gibt das Maximum zweiter Vektoren zurück.
        /// </summary>
        /// <param name="value1">Der erste Vektor.</param>
        /// <param name="value2">Der zweite Vektor.</param>
        /// <param name="result">Das Maximum der Komponenten als Vector<#=i#>.</param>
        public static void Max(ref Vector<#=i#> value1, ref Vector<#=i#> value2, out Vector<#=i#> result)
        {
            result.X = value1.X > value2.X ? value1.X : value2.X;
            result.Y = value1.Y > value2.Y ? value1.Y : value2.Y;
<# if (i > 2) #>
            result.Z = value1.Z > value2.Z ? value1.Z : value2.Z;
<# if (i > 3) #>
            result.W = value1.W > value2.W ? value1.W : value2.W;
<##>
        }

        /// <summary>
        /// Beschränkt die Komponenten eines Vektors auf einen bestimmten Bereich.
        /// </summary>
        /// <param name="value">Der Vektor.</param>
        /// <param name="min">Die untere Grenze.</param>
        /// <param name="max">Die obere Grenze.</param>
        /// <returns>Der Vektor im Bereich von min und max.</returns>
        public static Vector<#=i#> Clamp(Vector<#=i#> value, Vector<#=i#> min, Vector<#=i#> max)
        {
            Vector<#=i#> result;
            Clamp(ref value, ref min, ref max, out result);
            return result;
        }

        /// <summary>
        /// Beschränkt die Komponenten eines Vektors auf einen bestimmten Bereich.
        /// </summary>
        /// <param name="value">Der Vektor.</param>
        /// <param name="min">Die untere Grenze.</param>
        /// <param name="max">Die obere Grenze.</param>
        /// <returns>Der Vektor im Bereich von min und max.</returns>
        public static void Clamp(ref Vector<#=i#> value, ref Vector<#=i#> min, ref Vector<#=i#> max, out Vector<#=i#> result)
        {
            result.X = value.X > min.X ? value.X < max.X ? value.X : max.X : min.X;
            result.Y = value.Y > min.Y ? value.Y < max.Y ? value.Y : max.Y : min.Y;
<# if (i > 2) #>
            result.Z = value.Z > min.Z ? value.Z < max.Z ? value.Z : max.Z : min.Z;
<# if (i > 3) #>
            result.W = value.W > min.W ? value.W < max.W ? value.W : max.W : min.W;
<##>
        }

        /// <summary>
        /// Interpoliert linear zwischen zwei Werten.
        /// </summary>
        /// <param name="value1">Der erste Vektor.</param>
        /// <param name="value2">Der zweite Vektor.</param>
        /// <param name="amt">Der Gewichtungswert (0 = value1, 1 = value2).</param>
        /// <returns>Der interpolierte Wert.</returns>
        public static Vector<#=i#> Lerp(Vector<#=i#> value1, Vector<#=i#> value2, float amt)
        {
            Vector<#=i#> result;
            Lerp(ref value1, ref value2, amt, out result);
            return result;
        }

        /// <summary>
        /// Interpoliert linear zwischen zwei Werten.
        /// </summary>
        /// <param name="value1">Der erste Vektor.</param>
        /// <param name="value2">Der zweite Vektor.</param>
        /// <param name="amt">Der Gewichtungswert (0 = value1, 1 = value2).</param>
        /// <returns>Der interpolierte Wert.</returns>
        public static void Lerp(ref Vector<#=i#> value1, ref Vector<#=i#> value2, float amt, out Vector<#=i#> result)
        {
            float namt = 1 - amt;
            result.X = namt * value1.X + amt * value2.X;
            result.Y = namt * value1.Y + amt * value2.Y;
<# if (i > 2) #>
            result.Z = namt * value1.Z + amt * value2.Z;
<# if (i > 3) #>
            result.W = namt * value1.W + amt * value2.W;
<##>
        }

        /// <summary>
        /// Gibt das Punktprodukt der angegebenen Vektoren zurück. Handelt es sich dabei um Einheitsvektoren wird der Kosinus des eingeschlossenen Winkels zurückgegeben.
        /// </summary>
        /// <param name="value1">Der erste Vektor.</param>
        /// <param name="value2">Der zweite Vektor.</param>
        /// <returns>Das Punktprodukt.</returns>
        public static float Dot(Vector<#=i#> value1, Vector<#=i#> value2)
        {
            float result;
            Dot(ref value1, ref value2, out result);
            return result;
        }

        /// <summary>
        /// Gibt das Punktprodukt der angegebenen Vektoren zurück. Handelt es sich dabei um Einheitsvektoren wird der Kosinus des eingeschlossenen Winkels zurückgegeben.
        /// </summary>
        /// <param name="value1">Der erste Vektor.</param>
        /// <param name="value2">Der zweite Vektor.</param>
        /// <returns>Das Punktprodukt.</returns>
        public static void Dot(ref Vector<#=i#> value1, ref Vector<#=i#> value2, out float result)
        {
            result = value1.X * value2.X + value1.Y * value2.Y<# if (i > 2) #> + value1.Z * value2.Z<# if (i > 3) #> + value1.W * value2.W<##>;
        }

<# if (i == 3) #>
		/// <summary>
        /// Gibt das Kreuzprodukt der angegebenen Vektoren zurück. Dies ist die rechtshändige Senkrechte auf der von value1 und value2 definierten Ebene.
        /// </summary>
        /// <param name="value1">Der erste Vektor.</param>
        /// <param name="value2">Der zweite Vektor.</param>
        /// <returns>Das Kreuzprodukt.</returns>
        public static Vector3 Cross(Vector3 vector1, Vector3 vector2)
        {
            Cross(ref vector1, ref vector2, out vector1);
            return vector1;
        }

		/// <summary>
        /// Gibt das Kreuzprodukt der angegebenen Vektoren zurück. Dies ist die rechtshändige Senkrechte auf der von value1 und value2 definierten Ebene.
        /// </summary>
        /// <param name="value1">Der erste Vektor.</param>
        /// <param name="value2">Der zweite Vektor.</param>
        /// <returns>Das Kreuzprodukt.</returns>
        public static void Cross(ref Vector3 vector1, ref Vector3 vector2, out Vector3 result)
        {
            var x = vector1.Y * vector2.Z - vector2.Y * vector1.Z;
            var y = -(vector1.X * vector2.Z - vector2.X * vector1.Z);
            var z = vector1.X * vector2.Y - vector2.X * vector1.Y;
            result.X = x;
            result.Y = y;
            result.Z = z;
        }

<##>
        /// <summary>
        /// Normalisiert den angegebenen Vektor. Seine Länge beträgt danach 1.
        /// </summary>
        /// <param name="value1">Der erste Vektor.</param>
        /// <param name="value2">Der zweite Vektor.</param>
        /// <returns>Der normalisierte Vektor.</returns>
        public static Vector<#=i#> Normalize(Vector<#=i#> value)
        {
            return value / value.Length();
        }

        /// <summary>
        /// Normalisiert den angegebenen Vektor. Seine Länge beträgt danach 1.
        /// </summary>
        /// <param name="value1">Der erste Vektor.</param>
        /// <param name="value2">Der zweite Vektor.</param>
        /// <returns>Der normalisierte Vektor.</returns>
        public static void Normalize(ref Vector<#=i#> value, out Vector<#=i#> result)
        {
            result = value / value.Length();
        }

        // TODO: Transform + noch mehr Methoden.
        #endregion

        /// <inheritdoc/>
        public override bool Equals(object obj)
        {
            if (obj == null)
                return false;
            if (obj is Vector<#=i#>)
                return Equals((Vector<#=i#>)obj);
            return false;
        }

        /// <inheritdoc/>
        public bool Equals(Vector<#=i#> other)
        {
            return X == other.X && Y == other.Y<# if (i > 2) #> && Z == other.Z<# if (i > 3) #> && W == other.W<##>;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            unchecked
            {
                int hash = 17;
                hash = hash * 23 + X.GetHashCode();
                hash = hash * 23 + Y.GetHashCode();
<#if (i > 2) #>
                hash = hash * 23 + Z.GetHashCode();
<#if (i > 3) #>
                hash = hash * 23 + W.GetHashCode();
<##>
                return hash;
            }
        }

        /// <inheritdoc/>
        public override string ToString()
        {
            var builder = new StringBuilder();
            builder.Append("[X: ");
            builder.Append(X);
            builder.Append(", Y: ");
            builder.Append(Y);
<# if (i > 2) #>
            builder.Append(", Z: ");
            builder.Append(Z);
<# if (i > 3) #>
            builder.Append(", W: ");
            builder.Append(W);
<##>
            builder.Append("]");

            return builder.ToString();
        }
    }
}<#
}

manager.Process(true);
#><#+
public string Ctor(int count, params object[] @params)
{
	var builder = new StringBuilder();

	builder.Append("Vector");
	builder.Append(count);
	builder.Append("(");
	for (int i=0; i<count; i++)
	{
		if (i > 0)
			builder.Append(", ");
		builder.Append(@params[i]);
	}
	builder.Append(")");

	return builder.ToString();
}

public string Op(int count, string op, params object[] @params)
{
	var builder = new StringBuilder();

	builder.Append("Vector");
	builder.Append(count);
	builder.Append("(");
	for (int i=0; i<count; i++)
	{
		if (i > 0)
			builder.Append(", ");
		builder.Append(string.Format(@params[i].ToString(), op));
	}
	builder.Append(")");

	return builder.ToString();
}#>